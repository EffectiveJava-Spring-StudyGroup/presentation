## 아이템34. int 상수 대신 열거 타입을 사용하라.

<br>

### 자바의 참조타입 중 2가지

- 클래스 형태: 열거 타입 `enum`
- 인터페이스 형태: 어노테이션 `annotation`

<br>

### 열거 타입이란?

- 열거 타입 자체는 `class` 이다.
- 상수 하나당 자신의 인스턴스를 하나씩 만들어 `public static final` 필드로 공개한다.
    - 밖에서 접근할 수 있는 생성자를 제공하지 않으므로 사실상 final 이다.
    - 클라이언트가 인스턴스를 직접 생성, 확장할 수 없으므로 인스턴스들이 딱 하나씩만 존재한다.
    - 한마디로, 싱글턴을 일반화한 형태라고 볼 수 있다.

<br>

### 만약 열거 타입을 사용하지 않는다면?

- 다음과 같이 정수 열거 패턴 기법을 통해서 정수, 상수를 ‘한 묶음’ 선언해서 사용한다.
- 하지만, 이런 경우 여러 단점이 존재한다.
    - 컴파일 타입 안전성을 보장하지 않는다.
    - 평범한 상수 나열이라, 상수 값이 변경되면 클라이언트도 다시 컴파일해야한다.
    - 문자열로 출력하기가 어려워, 숫자로만 보이다보니 출력시 도움되지 않는다.

```java
public static final int FAIL = 0;
public static final int SUCCESS = 1;
```

<br>

### 열거 타입으로 변환한다면?

- 컴파일 타입 안전성을 보장한다.
    - 이전에는, 다른 생뚱맞은 상수 값이 들어와도 컴파일러가 경고 값을 보내지 못했다.
    - 이제는, 다른 타입의 값을 넘기려고 하면 컴파일 오류가 난다.
        - ex) ResultType ← StatusType 을 넘길 시 error!
- 열거 타입의 toString 메서드는 출력하기에 적합한 문자열을 내어준다.

```java
public enum ResultType {
		FAIL, SUCCESS;
}
```

- **더하여**, 열거 타입에서 임의의 메서드, 인터페이스 등을 구현할 수 있다.
    - 열거 타입 상수 각각을 특정 데이터와 연결지으려면 생성자에서 데이터를 받아 인스턴스 필드에 저장하면 된다.

```java
public enum ResultType {
  FAIL, SUCCESS;

  private final int score;
  private static final int MAX = 90;

  Rank(int score) {
    this.score = score;
  }

  public ResultType getResult(int score){
    if(score >= MAX) return SUCCESS;
    else return FAIL;
  }
}
```

<br>

### 현업에서는 어떻게 사용하고 있나?

- enum과 static을 선언한 constant는 목적이 다르다.
- enum은 연관된 상수들을 묶어서 추상화 시킨 것이고, constant는 값의 재할당을 막기 위한 목적에 맞다.
    - 때문에, 연관되어있는 ex.상태 값과 관련된 것들을 모두 `enum` 으로 관리해주고 있다.
    - 때문에, enum으로 관리하지 않고 `static final` 으로 관리하는 경우는? 값의 재할당을 막기 위한 목적일 때 주로 사용된다.
    
      +  해당 부분들, 목적에 맞게 설정되어있지 않는 부분들은 다시 한번 이유를 생각해봐야 할 것 같다.
    
<br>

----

### 결론

- (필요한 원소를 컴파일타임에 알 수 있는) 상수 집합 형태라면, 정수 열거 패턴보다는 열거 타입을 사용하자.
- 열거 타입에서 상수마다 다르게 동작해야 할 땐, 상수별로 메서드를 구현해서 사용하자.
    - 만약 일부 상수가 같은 행동을 공유한다면 전략 열거 패턴을 사용하자.

<br>
