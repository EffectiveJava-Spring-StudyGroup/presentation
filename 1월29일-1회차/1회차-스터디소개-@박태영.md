# 1회차 스터디소개 @박태영  

## :wave: 안녕하세요? 저는

- **하는 일은 ?**
  - 이른바 '제조업ERP' 운영업무 하는 1년차 자바개발자
  - 자바개발자인데, 프로그래밍 하러온건지 경로당에 컴퓨터 봉사활동을 하러 온건지 가끔 헷갈림 
- **스터디를 왜 ?** 
  - 취업준비하며 "모던 자바 인 액션":books:도 읽고 "이펙티브 자바":books:도 읽었지만, 정작 사용해볼 기회가 없었음
  - 다른 개발자들은 이런 개념들을 어떻게 적용하고 있는지 궁금함
- 앞으로 오늘과 같이, **짧은 개념설명 + 적용해본/적용못해본 경험**을 공유하면 좋겠음
  - 처음 입사했을때는, 왜 우리는 테스트코드가 없나 기술문서가 없고 왜 각주만 있나 의문이 들었음
  - 시간이 지나면서 그런 고민들도 잊어버리고 타성에 젖어버림
  - 이 스터디를 계기로 서로 자극도 주고받았으면 좋겠음
  
  
  

## 아이템42 : 익명클래스보다 람다를 사용하라 (요약)

- **람다란?**
  - 함수를  `( 파라미터 ) -> { expression 또는 statement }`와 같이 화살표로 표현
  - Comparator 익명클래스 대신, 파라미터로 전달할 함수를 화살표로 표현 (코드가 짧아진다)



- 옛날옛날 자바개발자들은, '함수 타입'을 표현하기 위해 추상메서드가 하나인 인터페이스(또는 추상클래스) 사용

```java
Collections.sort(words, new Comparator<String>(){
  public int compare(String s1, String s2){
    return Integer.compare(s1.length(), s2.length());
  }
});
```

> :sob:**'함수 타입'이 뭔데?** 다른 함수의 파라미터로 전달할 수 있는 것을 말함
>



- 자바8에서는 기존 개발자들의 노하우를 계승하되, 람다(화살표형 함수 `()->{}`)로 함수형 인터페이스 인스턴스를 생성할 수 있게 해줌

```java
Collections.sort(words, (s1, s2) -> Integer.compare(s1.length(), s2.length()));
```
> **'람다'가 뭔데?**
> - `( 파라미터 ) -> expression`
> - `( 파라미터 ) -> { statements }` //return을 생략하면 Void 반환으로 간주

> **함수형 인터페이스 디스크립터**(= 메서드 시그니처)
>
> - 람다에서 뭘 파라미터로 받아서 뭘 반환하는지
>   - 표준형이 몇가지 정해져 있음
>   - 물론, 직접 정의해서 사용할 수도 있음
> - 활용 예시
>   - Supplier의 디스크립터는 `()->{Object}`임
>   - 평가를 지연할때 사용할 수 있음, 이를테면 `calculateThis(()->{target})`
>   - 위 코드에서 target은 런타임에 해당 함수가 호출될때 평가됨




- 또는 `::` 연산자로 메서드를 참조하여 다른 함수의 인자로 넘길 수 있게 해줌

```java
Collections.sort(words, comparingInt(String::length));
```



- :rotating_light: **람다를 사용할 때 주의할 점** 

  - 람다의 메서드 시그니처, 파라미터 타입은 컴파일타임에 추론됨 (형변환에 주의)
  - 람다는 이름이 없기 때문에 디버깅이 어려움, 코드가 길어지면 가독성이 떨어짐 (세 줄 이하로 권장)
  - 람다는 자기자신을 this 키워드로 참조할 수 없음
  - 구현체별로 직렬화 형태가 다를 수 있으므로, 직렬화는 가급적 피해야함
  - 덧) 내/외부 변수를 final로 취급해야함
    > **왜냐하면,** 람다 자체가 '함수 타입'을 표현, '부작용 없는 함수'를 목표로 하기 때문임
  - 덧) 람다를 모르는 사람이 람다를 보면, 정말 난해하기짝이없음

​          

## 아이템45 : 스트림을 사용할때는 주의해서 사용하라 (요약)

- **스트림이란?** 
  - `원본데이터.메서드().메서드().출력()`과 같이 원본데이터에 메서드를 이어서 순차/병렬처리 가능
  - 다량의 유/무한 데이터를 순차 혹은 병렬처리를 손쉽게 할 수 있음 (스레드 신경안쓰고!!)
  - 중간연산은 종단연산이 있어야 수행된다.

```java
words.collect(groupingBy(word -> alphabetize(word)))
  .values().stream()
  .filter(group -> group.size() >= minGroupSize)
  .forEach(g -> System.out.println(g.size() + ": "+ g));
```

> **스트림을 어떻게 쓰는건데?** `소스스트림.중간연산().중간연산().종단연산();`
> 분할정복 방식으로 소스스트림이 처리된다. 
> 소스스트림에 순차적으로 처리하려면 `소스스트림.순차처리().중간연산().종단연산()`처럼 호출해야한다.

> **병렬처리는 어떻게 하는데?** 소스스트림.병렬화().중간연산().중간연산().종단연산();
> 스레드 병렬처리 방식으로 처리된다.

  

- :rotating_light: **스트림+람다 vs 컬렉션+반복문**
  - 스트림은 수행할 연산을 주로 람다 형태로 전달받는다. 어떤 경우에 효과적일까?
  - 람다는 final이거나 사실상 final인 변수만 읽을 수 있다. 따라서 <u>외부 변수를 변경해야하면 반복문이 낫다.</u>
  - 람다는 break/continue를 할 수 없다. <u>연산을 중간에 건너뛰거나 중단해야하면 반복문이 낫다.</u>
  - 그런데 람다는, 연산 수행 전 값을 따로 보관하지 않는다. 이를테면 `소스스트림.필터링().출력()` 한다면, 출력후 소스스트림에 다시 접근할 수 없다. <u>연산 수행전/후 값에 동시에 접근해야한다면 반복문이 낫다.</u>
  - 그런데 람다는 전체 시퀀스를 특정 형태로 변환/필터링/결합/컬렉션으로모으기 등 연산을 순차/병렬처리하려면 람다가 낫다.

   

## 적용해본 경험 : NAS 파일을 스트림/람다로 처리

- [아이템45,61/34,62 배치프로그램 개발 : `스트림/박싱` > `toMap/forEach/filter, mapToLong`](https://github.com/tae0y/EffectiveJava/blob/main/아이템%2039.%20명명%20패턴보다%20애너테이션을%20사용하라.md#아이템45613462-배치프로그램-개발--스트림박싱--tomapforeachfilter-maptolong)

- 특정 NAS에 접근해 사진 리사이징하는 배치를 개발했다.
  - 🌱 : 음.. 방향만 잡아주실 수 있나요?
  - 😎 : 자바에서 파일 접근하면 락걸리니까 리사이징하고 엎어칠때 주의하고, 참고할 코드는 검색~
- 사용한 것 같은 원칙
  - **==아이템 45. 스트림은 주의해서 사용하라==**
    - ==File 객체에서 Walk로 해당 디렉토리내 파일경로 리스트를 스트림으로 조회==
    - ==스트림에서 toMap, forEach, filter 메서드를 알고 있으니까 코드를 편하게 짰다==
  - 아이템 61. 박싱된 기본 타입보다는 기본 타입을 사용하라
    - 리사이징 로직 수행하기 전후로 디렉토리내 파일 용량을 체크해서 로그에 찍었는데
    - 처음에는 Long으로 reduce하다가, 아이템61이 생각나 mapToLong을 사용해 기본형 특화스트림으로 변경했다
- 사용하지 못한 것 같은 원칙
  - 아이템 34. int 상수 대신 열거 타입을 사용하라
  - 아이템 62. 다른 타입이 적절하다면 문자열 사용을 피하라
    - 디렉토리경로, 리사이징 가로너비를 문자열로 전달받는다 (변수를 외부에서 입력)
  - 대신에.. 유효성 검사하는 코드를 추가했다
    - 디렉토리경로가 유효한지, 리사이징 가로너비가 int로 형변환 잘 되는지

----

- **스트림/람다를 실무에서 조금이라도 써보고 싶었다.**

  - 사실 스트림과 람다를 적용의 '안 좋은 예'이다.

  - 이제 이 배치를 수정하려는 사람은.. 람다와 스트림을 공부해야한다.

  - 약간의 변명을 하자면, 리사이징이 오래걸리면 스트림으로 병렬처리하려고했다.

```java
Files.walk("NAS경로")
  .toMap ( file -> file.toImage() ) 
  .filter( image -> image.width() >= reiszeTargetSize )
  .forEach( image -> {
    Image newImage = image.resize(reiszeTargetSize);
    //새 파일 생성
  });
```

- 만약 스트림/람다를 사용하지 않았다면
  - 이쪽이 가독성이 더 좋다.
```java
fileList = Files.walk("NAS경로").collect(Collectors.toList()); //컬렉션으로 변경
for(File file : fileList) {
  Image img = file.toImage();
  if(image.width() >= resizeTargetSize) continue;
  Image newImage = image.resize(reiszeTargetSize);
  //새 파일 생성
}
```

  

## 생각해볼거리 : 왜 스트림/람다 사용 못해봤을까? 로직이 DB에 있음

- 이거 말고는 스트림을 사용해본적 없음. 왜 실무에서 사용해보기가 어려울까?
  - 데이터 처리, 비즈니스 로직은 대부분 DB에 몰려있음 (mybatis + mssql)
  - **비즈니스 로직이 어플리케이션단에 있어야, 스트림도 쓰고 람다도 쓰고 할 수 있음.**
- 그러면 비즈니스 로직은 어디에 위치하는게 좋을까? [**Why should business logic not be in the database?**](https://www.quora.com/Why-should-business-logic-not-be-in-the-database)
  - DB 서버는 scalable하기 쉽지않다. 라이센스가 비싸다. 어플리케이션은 차라리 낫다.
  - DB에 비즈니스 로직이 있으면, 오류나 수정/튜닝할때 어플리케이션 개발자 혼자서는 못한다.
- **정리하자면, 비즈니스 로직이 위치한 계층은**
  - 확장이 용이해야하고 (서버자원 부족하면, 추가로 라이센스도 사고 서버도 사고)
  - 변경이 용이해야하고 (비즈니스로직을 수정해야하면 쉽게쉽게 바꿀 수 있어야)
  - 다른 계층이 변경될때 영향을 받지 않도록 구성해야 하겠다. (어플리케이션 계층 스펙이 달라진다고 영향받으면 안되겠다)  
- 그런의미에서, 현재 업무로는 스트림도 람다도 사용해보기는 쉽지 않을 것 같다.

----

- **확장이란**

  - 수직적 규모확장 : 특정 노드 자원을 늘리는 방법이다. 서버에 메모리를 추가해 처리능력을 키움.

  - 수평적 규모확장 : 노드의 개수를 늘리는 방법. 서버를 추가함으로써 서버 한 대가 다루는 부하를 줄임.

  - 서버 부하 분산 : 서버에 걸리는 부하를 여러 대의 서버에 균일하게 분산시켜, 서버 한 대 때문에 전체 시스템이 죽거나 다운되는 상황을 방지한다.

  - 데이터베이스 역정규화 : SQL과 같은 관계형 데이터베이스의 조인 연산은 시스템이 커질수록 굉장히 느려지므로, 필요에 따라 데이터베이스를 합쳐 역정규화할 수 있다.

- 내 경우에는? 어떻게 하고있나?
  - 문서중앙화솔루션(회사내부용 구글드라이브 같은것) 
  - 01/02서버 이중화 + L4를 사용해 라운드로빈으로 부하분산중
  
- 만약 확장해야한다면?
  - 서버 자원을 늘린다면, 웹서버 라이센스 비용 지불하고 메모리 늘리기만 하면됨.
  - 서버를 늘린다면, 서버에 시스템재구축 + 웹서버 라이센스비용 등 지불해야함.
  - 서버 부하분산을 위해서는, L4에 서버IP 추가해서 부하를 분산해야하겠음.
  - 그 전에 너무 로드가 많이 걸리는 작업은 제한하거나 순차/병렬처리할 수 있도록 개선하는게 더 좋을듯.

> **코딩인터뷰완전분석, 시스템 설계 및 규모 확장성**
> [https://github.com/CodingInterviewStudy/CrackingTheCodingInterview/wiki/5주차-3#시스템-설계-및-규모-확장성](https://github.com/CodingInterviewStudy/CrackingTheCodingInterview/wiki/5주차-3#시스템-설계-및-규모-확장성)

​    

## 더 공부할만한 주제 : 함수형을 왜쓸까? 부작용 없는 함수란?

- **'함수 타입'을 왜 쓰는 건데? 이른바 '함수형'은?** 
- 함수를 인자로 전달할 수 있으면, 함수를 조합하거나 모듈화해서 재사용하기 편하다.
  - 일급함수는 인자로 전달하거나 결과로 반환, 자료구조에 저장할 수 있다.
  - 고차함수는 하나 이상의 함수를 인자로 받아 다른 함수를 반환하는 함수다. (미분처럼)
  - 부작용이 없는 함수를 사용하면, 자료구조가 변경될 걱정을 하지 않아도 된다.
    - 영속 자료구조는 기존 버전의 자신을 보존한다.
    - 그렇다면 연산결과는? 기존 영속 자료구조를 복사해 사용하고, 새 자료구조를 반환한다.

- 부작용이 없으면(=참조투명성을 유지하면, =같은 파라미터에 같은 결과가 나온다면)
  - 연산 결과를 캐싱하여 사용할 수 있다.
  - 해당 함수가 올바르게 동작하는지만 테스트하면 오류 원인을 찾을 수 있다.
  - 부수효과가 없으므로 테스트용 가짜 객체를 만들 필요가 없다.
  - 외부 요인에서 자유롭고, 값의 변경이 일어나지 않고, 동시성 문제에서 자유로우므로, 함수를 조합해서 사용하기가 더 쉽다.

> **모던자바인액션, 19장 - 함수형 프로그래밍 기법**
> [https://github.com/Modern-Java-in-Action/Online-Study/wiki/CHAP19](https://github.com/Modern-Java-in-Action/Online-Study/wiki/CHAP19)

   

## 질의응답

- 람다를 사용하면 전략패턴을 구현하기 더 쉽다는 것인가? 아님
  - 우선 책에서는 람다를 사용해야 전략패턴을 구현하기 쉽다는 내용은 없다.
  - 익명클래스도, 람다도 각자 특징이 있으니 상황에 맞게 사용하면 될것 같다.
  - 람다는 this 키워드로 자기자신을 가리킬 수 없다.
    - 람다에서 this 키워드를 사용하면 가장 가까운 객체 인스턴스를 가리킨다.
    - [CHAP02 · Modern-Java-in-Action/Online-Study Wiki (github.com)](https://github.com/Modern-Java-in-Action/Online-Study/wiki/CHAP02#this-키워드)
  - 익명클래스도 람다도 외부변수를 final로 취급해야 한다.
    - 자바의 람다는 함수형 인터페이스의 인스턴스로서, 힙 메모리 영역에 저장된다.
    - 람다 바깥의 외부변수는 스택에 위치해 있는데, 람다는 이 변수를 복사해서 사용한다 (이런 동작을 변수 캡처라고 한다)
    - 따라서 람다 밖의 외부변수를 변경할 수가 없다.
    - 람다에서 참조하는 외부 변수는 final이거나 사실상 final이어야 한다. (아니면 컴파일오류가 난다)
    - [CHAP02 · Modern-Java-in-Action/Online-Study Wiki (github.com)](https://github.com/Modern-Java-in-Action/Online-Study/wiki/CHAP02#22-익명-클래스)
- map은 본것 같은데, 메서드 이름이 toMap이 맞나? 헷갈림.. toMap이 맞긴함!
  - collect로 Collections.toMap() 함수를 전달하는 것임. 헷갈렸음. 
- 비즈니스로직을 어디서 처리하는지는, 
  - **ORM/SQL** : 얼마나 DB에 종속적인지 Mybatis/JPA 등 어떤 프레임워크에 쓰는지 등에 따라 달라진다.
  - **DB의종류** : MSSQL의 경우 사용자별로 권한을 설정할 수 있어 백단 개발자가 쿼리까지 작성하기 쉽다. 반면 Oracle은 DBA가 전권을 쥐고 쿼리수정도 DBA가 해야 한다. DB의 종류에 따라서도 달라진다.
  - **테이블구조** : 테이블구조가 단순한 경우 JOIN/CRUD 등을 어플리케이션단에서 하는 것이 더 편하겠다. 반면 테이블구조가 복잡한 경우에는 업무로직을 DB단에서 쿼리로 작성하는 것이 더 편하다(이를테면 다중 조인을 자바에서 어떻게 표현할 것인가?)
  - **업무형태** : 업무형태별로도 아키텍처 구조가 매우 다르므로, 다른 개발팀과도 계속 교류할것!
    - 우리는 대고객서비스가 아니고 월마감 시스템이고 테이블구조가 복잡하다. MSSQL로 개발편의성을 높이고 mybatis로 복잡한 로직을 DB단에서 처리하며, 어플리케이션은 WAS 자바힙을 6GB로 관리하며 대부분의 무거운 로직을 DB서버 자원을 사용해 처리하고 있다. 
    - 반면, 대고객서비스에 일마감시스템의 경우, mongodb와 클라우드 서비스를 사용해 사용자 요청이 몰릴 때 자동으로 스케일러블하게 구축되어 있으며, 일마감시 mongodb에 쌓인 데이터를 일괄로 오라클db로 모아서 처리한다. 